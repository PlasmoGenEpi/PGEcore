# ========================= C Code from THEREALMcCOIL repo =================
#
#
# the folloing code is generated by concatenating
# llfunction_het.c and  McCOIL_categorical_code.c files
#
# See: https://github.com/EPPIcenter/THEREALMcCOIL/tree/master/categorical_method
c_code <- '
#include <R.h>
#include <Rmath.h>
#include <stdio.h>
#include <time.h>

double logLike_het(int M, double P, double S2, double e1, double e2) {
  double lltrue = 0.0;
  if (S2 == 1) {
    lltrue = log((1 - e1) * ((double)pow(P, M)) +
                 e2 / 2 * (1 - (double)pow(P, M) - (double)pow((1 - P), M)));
  } else if (S2 == 0) {
    lltrue = log((1 - e1) * ((double)pow((1 - P), M)) +
                 e2 / 2 * (1 - (double)pow(P, M) - (double)pow((1 - P), M)));
  } else if (S2 == 0.5) {
    if ((M == 1) && (e1 == 0))
      lltrue = -9999999;
    else
      lltrue =
          log(e1 * ((double)pow(P, M)) + e1 * ((double)pow((1 - P), M)) +
              (1 - e2) * (1 - (double)pow(P, M) - (double)pow((1 - P), M)));
  } else
    lltrue = 0.0;
  return (lltrue);
}

void McCOIL_categorical(int *max, int *iterations, int *n0, int *k0, double *sampleS2, int *M0, double *P0, double *error1, double *error2, char **file_index, char **path, int *err_method0) {


	double varP=0.1;
	double varE=0.0001;
	double upper_bound_e1=0.2;
	double upper_bound_e2=0.2;


	int i=0, j=0, prime=0, x=0, y=0;
	double sumori=0, sumcan=0;

	GetRNGstate();


	int max_moi= *max;
	int iter = *iterations;
	int n = *n0, k = *k0;
	int err_method= *err_method0;
	double e1 = *error1, e2 = *error2;
	int M[(n+1)], Mcan[(n+1)], Maccept[(n+1)];
	double P[(k+1)], Pcan[(k+1)];
	int Paccept[(k+1)];
	double ll[(n+1)][(k+1)];
	double llcan[(n+1)][(k+1)];
	double S2[(n+1)][(k+1)];
	double q1=0.0, q2=0.0;
	double e1_can, e2_can;
	int e1_accept=0, e2_accept=0;
	for (i=1;i<=n;i++){
		M[i]= M0[i-1];
		Mcan[i]= M[i];
		Maccept[i]= 0;
		for (j=1;j<=k;j++){
			S2[i][j]= sampleS2[(i-1)*k+j-1];
			if (i==1) {
				P[j]= P0[j-1];
				Pcan[j]= P[j];
				Paccept[j]= 0;
			}
		}
	}
	time_t t1, t2;
	t1 = time(NULL);


	char var_file[1000];
	sprintf(var_file, "%s/%s", path[0], file_index[0]);
	FILE *V0 = fopen(var_file, "w");




	for (i=1;i<=n;i++){
		for (j=1;j<=k;j++){
			ll[i][j]= logLike_het(M[i], P[j], S2[i][j], e1, e2);
			llcan[i][j]= ll[i][j];
		}
	}
	for (i=1;i<=iter;i++){

		for (j=1; j<=n; j++){
			prime = rbinom(1,0.5);
			if (prime==0) prime=-1;
			Mcan[j]= M[j] + prime;
			if ((Mcan[j]<=max_moi) && (Mcan[j]>0)){
				sumcan=0;
				sumori=0;
				for (x=1;x<=k;x++){
					llcan[j][x]=logLike_het(Mcan[j], P[x], S2[j][x], e1, e2);
					sumcan+=llcan[j][x];
					sumori+=ll[j][x];
				}

				if (log(runif(0.0,1.0)) < (sumcan-sumori)) {
					M[j]=Mcan[j];
					Maccept[j]++;
					for (x=1;x<=k;x++){
						ll[j][x]=llcan[j][x];
					}
				}

				else {
					Mcan[j]=M[j];
					for (x=1;x<=k;x++){
						llcan[j][x]=ll[j][x];
					}
				}
			}
			else {
				Mcan[j]=M[j];
			}
		}

		for (j=1; j<=k; j++){
			Pcan[j]= rnorm(P[j],varP);
			if ((Pcan[j]<1) && (Pcan[j]>0)){
				sumcan=0;
				sumori=0;
				for (y=1;y<=n;y++){
					llcan[y][j]=logLike_het(M[y], Pcan[j], S2[y][j], e1, e2);
					sumcan+=llcan[y][j];
					sumori+=ll[y][j];
				}

				if (log(runif(0.0,1.0)) < (sumcan-sumori)) {
					P[j]=Pcan[j];
					Paccept[j]++;
					for (y=1;y<=n;y++){
						ll[y][j]=llcan[y][j];
					}
				}

				else {
					Pcan[j]=P[j];
					for (y=1;y<=n;y++){
						llcan[y][j]=ll[y][j];
					}
				}
			}
			else {
				Pcan[j]=P[j];
			}
		}

		if (err_method==2){
			e1 = runif(0.0,upper_bound_e1);
			e2 = runif(0.0,upper_bound_e2);
		}
		if (err_method==3){

			e1_can= rnorm(e1,varE);
			if ((e1_can>=0) && (e1_can<=1)){

				sumcan=0;
				sumori=0;
				for (y=1;y<=n;y++){
					for (x=1;x<=k;x++){
						llcan[y][x]=logLike_het(M[y], P[x], S2[y][x], e1_can, e2);
						sumcan+=llcan[y][x];
						sumori+=ll[y][x];
					}
				}

				if (log(runif(0.0,1.0)) < (sumcan-sumori)) {
					e1= e1_can;
					e1_accept++;
					for (y=1;y<=n;y++){
						for (x=1;x<=k;x++){
							ll[y][x]=llcan[y][x];
						}
					}
				}

				else {
					e1_can= e1;
					for (y=1;y<=n;y++){
						for (x=1;x<=k;x++){
							llcan[y][x]=ll[y][x];
						}
					}
				}
			}
			else{

				e1_can= e1;
			}


			e2_can= rnorm(e2,varE);
			if ((e2_can>=0) && (e2_can<=1)){

				sumcan=0;
				sumori=0;
				for (y=1;y<=n;y++){
					for (x=1;x<=k;x++){
						llcan[y][x]=logLike_het(M[y], P[x], S2[y][x], e1, e2_can);
						sumcan+=llcan[y][x];
						sumori+=ll[y][x];
					}
				}

				if (log(runif(0.0,1.0)) < (sumcan-sumori)) {
					e2= e2_can;
					e2_accept++;
					for (y=1;y<=n;y++){
						for (x=1;x<=k;x++){
							ll[y][x]=llcan[y][x];
						}
					}
				}

				else {
					e2_can= e2;
					for (y=1;y<=n;y++){
						for (x=1;x<=k;x++){
							llcan[y][x]=ll[y][x];
						}
					}
				}
			}
			else{

				e2_can= e2;
			}

		}



		fprintf(V0,"%d", i);
		for (x=1;x<=n;x++) fprintf(V0,"\\t%d",  M[x]);
		for (x=1;x<=k;x++) fprintf(V0,"\\t%.6f", P[x]);
		if (err_method==3) fprintf(V0,"\\t%.6f\\t%.6f", e1, e2);
		fprintf(V0,"\\n");

	}

	fprintf(V0, "total_acceptance");
	for (x=1;x<=n;x++) fprintf(V0,"\\t%d",  Maccept[x]);
	for (x=1;x<=k;x++) fprintf(V0,"\\t%d", Paccept[x]);
	if (err_method==3) fprintf(V0,"\\t%d\\t%d", e1_accept, e2_accept);
	fprintf(V0,"\\n");

	t2 = time(NULL);
	Rprintf("Time = %.2f s\\n", difftime(t2, t1));
	fclose(V0);
	PutRNGstate();
}
'

c_file <- "McCOIL_categorical_code.c"
writeLines(c_code, c_file)

cmd <- paste("R CMD SHLIB", c_file)
system(cmd)

# ======================== R code from THEREALMcCOIL =====================
#
McCOIL_categorical = function(data,
                              maxCOI = 25,
                              threshold_ind = 20,
                              threshold_site = 20,
                              totalrun = 10000,
                              burnin = 1000,
                              M0 = 15,
                              e1 = 0.05,
                              e2 = 0.05,
                              err_method = 1,
                              path = getwd(),
                              output = "output.txt") {
  mcCoil_categorical_code_location = '/McCOIL_categorical_code.so'
  if (Sys.info()['sysname'] == 'Windows') {
    mcCoil_categorical_code_location = '/McCOIL_categorical_code.dll'
  }

  In_ind = rep(NA, nrow(data))
  In_site = rep(NA, ncol(data))
  for (i in (1:nrow(data))) {
    if ((length(data[i, ]) - sum(data[i, ] == -1)) >= threshold_ind)
      In_ind[i] = TRUE
    else
      In_ind[i] = FALSE
  }
  for (i in (1:ncol(data))) {
    if ((length(data[, i]) - sum(data[, i] == -1)) >= threshold_site)
      In_site[i] = TRUE
    else
      In_site[i] = FALSE
  }

  ## remove sites and individuals with too much missing data
  simpleS = data[In_ind, ]
  simpleS = simpleS[, In_site]

  ## remove sites with P=0 or 1
  P = rep(NA, ncol(simpleS))
  for (j in (1:ncol(simpleS))) {
    temp = simpleS[, j]
    P[j] = (sum(temp == 1) + 0.5 * sum(temp != 0 &
      temp != 1 & temp != -1)) / sum(temp != -1)
  }
  In = (P != Inf & P != "NaN" & P != 0 & P != 1)
  simpleS2 = simpleS[, In]

  select_pos = colnames(data)[In_site][In]
  select_ind = rownames(data)[In_ind]

  n = nrow(simpleS2)
  k = ncol(simpleS2)
  simpleS2_vec = as.vector(t(simpleS2))
  P0 = P[In]
  M0 = rep(M0, n)

  if ((n > 10 & k > 10)) {
    dyn.load(paste(path, mcCoil_categorical_code_location, sep = ""))
    K <- .C(
      "McCOIL_categorical",
      as.integer(maxCOI),
      as.integer(totalrun),
      as.integer(n),
      as.integer(k),
      as.double(simpleS2_vec),
      as.integer(M0),
      as.double(P0),
      as.double(e1),
      as.double(e2),
      as.character(output),
      as.character(path),
      as.integer(err_method)
    )
    dyn.unload(paste(path, mcCoil_categorical_code_location, sep = ""))
  } else {
    stop(paste("Sample size is too small (n=", n, ", k=", k, ").", sep = ""))
  }

  ## summarize results
  outputMCMC1 = read.table(paste(path, "/", output, sep = ""), head = F)
  meanM = as.numeric(round(apply(outputMCMC1[(burnin + 1):totalrun, (1:n) + 1], 2, mean)))
  meanP = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, ((1:k) + n + 1)], 2, mean))
  medianM = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, (1:n) + 1], 2, median))
  medianP = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, ((1:k) + n + 1)], 2, median))
  M975 = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, (1:n) + 1], 2, function(x)
    quantile(x, probs = 0.975)))
  P975 = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, ((1:k) + n + 1)], 2, function(x)
    quantile(x, probs = 0.975)))
  M025 = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, (1:n) + 1], 2, function(x)
    quantile(x, probs = 0.025)))
  P025 = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, ((1:k) + n + 1)], 2, function(x)
    quantile(x, probs = 0.025)))
  sdM = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, (1:n) + 1], 2, sd))
  sdP = as.numeric(apply(outputMCMC1[(burnin + 1):totalrun, ((1:k) + n + 1)], 2, sd))

  if (err_method == 3) {
    mean_e1 = as.numeric(mean(outputMCMC1[(burnin + 1):totalrun, (k + n + 2)]))
    median_e1 = as.numeric(median(outputMCMC1[(burnin + 1):totalrun, (k + n + 2)]))
    e1_975 = as.numeric(quantile(outputMCMC1[(burnin + 1):totalrun, (k + n + 2)], probs = 0.975))
    e1_025 = as.numeric(quantile(outputMCMC1[(burnin + 1):totalrun, (k + n + 2)], probs = 0.025))
    sd_e1 = as.numeric(sd(outputMCMC1[(burnin + 1):totalrun, (k + n + 2)]))

    mean_e2 = as.numeric(mean(outputMCMC1[(burnin + 1):totalrun, (k + n + 3)]))
    median_e2 = as.numeric(median(outputMCMC1[(burnin + 1):totalrun, (k + n + 3)]))
    e2_975 = as.numeric(quantile(outputMCMC1[(burnin + 1):totalrun, (k + n + 3)], probs = 0.975))
    e2_025 = as.numeric(quantile(outputMCMC1[(burnin + 1):totalrun, (k + n + 3)], probs = 0.025))
    sd_e2 = as.numeric(sd(outputMCMC1[(burnin + 1):totalrun, (k + n + 3)]))
  }
  if ((err_method == 1) | (err_method == 2)) {
    output_sum = data.frame(cbind(
      rep(output, (n + k)),
      c(rep("C", n), rep("P", k)),
      c(select_ind, select_pos),
      c(meanM, meanP),
      c(medianM, medianP),
      round(c(sdM, sdP), digits = 5),
      c(M025, P025),
      c(M975, P975)
    ))
  }
  else {
    output_sum = data.frame(cbind(
      rep(output, (n + k + 2)),
      c(rep("C", n), rep("P", k), "e1", "e2"),
      c(select_ind, select_pos, "e1", "e2"),
      c(meanM, meanP, mean_e1, mean_e2),
      c(medianM, medianP, median_e1, median_e2),
      round(c(sdM, sdP, sd_e1, sd_e2), digits = 5),
      c(M025, P025, e1_025, e2_025),
      c(M975, P975, e1_975, e2_975)
    ))
  }
  colnames(output_sum) = c("file",
    "CorP",
    "name",
    "mean",
    "median",
    "sd",
    "quantile0.025",
    "quantile0.975")
  write.table(
    output_sum,
    paste(path, "/", output, "_summary.txt", sep = ""),
    sep = "\t",
    col.names = T,
    row.names = F,
    quote = F
  )

}

# ============================ test code =========================

input_fn <- "./THEREALMcCOIL/categorical_method/input_test.txt"
data0 <- read.table(input_fn, head = TRUE)
data <- data0[, -1]
rownames(data) <- data0[, 1]

McCOIL_categorical(
  data, maxCOI = 25, threshold_ind = 20, threshold_site = 20,
  totalrun = 1000, burnin = 100, M0 = 15, e1 = 0.05, e2 = 0.05,
  err_method = 3, path = getwd(), output = "output_test.txt")
