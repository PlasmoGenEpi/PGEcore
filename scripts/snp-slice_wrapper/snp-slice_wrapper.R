#Usage: Rscript snp-slice_wrapper.R --gap 50 --aa_calls
#/home/alfred/github_pipelines/PGEcore/data/example_amino_acid_calls.tsv
#--output final_stave2.tsv --snp_slice_dir /home/alfred/github_pipelines/snp-slice
#--model 3

library(dplyr)
library(tidyr)
library(readr)
library(optparse)
library(stringr)
library(tibble)
library(roxygen2)

#the roxygen docstrings were generated by AI and edited by me (Alfred Simkin)

#' @title Convert amino acid tables from PGE format to SNPslice format
#'
#' @description This function takes an amino acid table in PGE format as input,
#' processes it to identify sites with at most two unique alleles, and then
#' generates two tables in SNPslice format: one for reference allele counts and
#' one for alternate allele counts.
#'
#' @param input_path Path to the input PGE formatted amino acid table file. This
#' file should contain (at a minimum) the columns 'gene_id', 'aa_position'
#' (amino acid position), 'aa' (observed amino acid), 'ref_aa' (reference amino
#' acid), and 'read_count'.
#' @param output_ref Path to the output file where the reference allele counts
#' in SNPslice format will be written.
#' @param output_alt Path to the output file where the alternate allele counts
#' in SNPslice format will be written.
#'
#' @details
#' The function performs the following steps:
#' \itemize{
#'   \item Reads the input table.
#'   \item Creates a unique identifier 'gene_pos' by combining the gene ID and amino acid position.
#'   \item Identifies sites ('gene_pos') that have fewer than three unique amino acid alleles. (These are bi-allelic, a requirement of SNP-slice).
#'   \item Filters the data to include only these valid sites.
#'   \item Calculates the counts of reference and alternate alleles for each specimen and gene position. An allele is considered the reference if it matches 'ref_aa', and alternate otherwise.
#'   \item Pivots the reference and alternate counts into a wide format suitable for SNPslice, with 'specimen_id' as rows and 'gene_pos' as columns. Missing values are filled with 0.
#'   \item Writes the resulting reference and alternate count tables to the specified output files.
#' }
#'
#' @return This function does not explicitly return a value but writes two
#' tab-separated files to the paths specified by \code{output_ref} and
#' \code{output_alt}. The code is set up this way in order to use the official
#' SNP-slice which has hardcoded output directories.
#'
#' @importFrom dplyr %>% mutate group_by summarize filter pull select
#' @importFrom tidyr pivot_wider
#' @importFrom readr read_tsv
#'
#' @examples
#' \dontrun{
#' # Assuming 'example_amino_acid_calls.tsv' exists in the working directory
#' create_SNP_slice_input(
#'   input_path = "example_amino_acid_calls.tsv",
#'   output_ref = "ref_counts.tsv",
#'   output_alt = "alt_counts.tsv"
#' )
#' }
#'
#' @export
create_SNP_slice_input <- function(input_path, output_ref, output_alt) {
    dir.create(file.path('inputdata'), showWarnings = FALSE)
    # modified from a chatGPT conversion of a python script I wrote
    # Read the input file
    data <- read_tsv(input_path, show_col_types = FALSE)
    # Create gene_position identifier
    data <- data %>% 
      mutate(gene_pos = paste(gene_id, aa_position, sep = "_"))
    # Identify valid sites with fewer than 3 unique alleles
    good_alleles <- data %>% 
      group_by(gene_pos) %>% 
      summarize(unique_alleles = n_distinct(aa)) %>% 
      filter(unique_alleles < 3) %>% 
      pull(gene_pos)

    # Filter data to include only good alleles
    data <- data %>% 
      filter(gene_pos %in% good_alleles)

    # Compute ref and alt counts
    ref_alt_counts <- data %>% 
      mutate(ref_count = ifelse(ref_aa == aa, read_count, 0),
             alt_count = ifelse(ref_aa != aa, read_count, 0)) %>%
      group_by(specimen_id, gene_pos) %>% 
      summarize(ref_count = sum(ref_count),
                alt_count = sum(alt_count), .groups = "drop")
    

    # Pivot to wide format
    ref_counts <- ref_alt_counts %>% 
      select(specimen_id, gene_pos, ref_count) %>% 
      pivot_wider(names_from = gene_pos, values_from = ref_count, values_fill = 0)

    alt_counts <- ref_alt_counts %>% 
      select(specimen_id, gene_pos, alt_count) %>% 
      pivot_wider(names_from = gene_pos, values_from = alt_count, values_fill = 0)

    # Write to files
    write.table(ref_counts, output_ref, sep = "\t", row.names = FALSE, quote = FALSE)
    write.table(alt_counts, output_alt, sep = "\t", row.names = FALSE, quote = FALSE)
}

#' @title Create a table of reference and alternate alleles.
#'
#' @description This function reads an input file, extracts reference and
#' alternate allele information for each gene position, and writes this
#' information to a new file. This file is later used for parsing final STAVE
#' file format.
#'
#' @param input_path Path to the input file containing amino acid data.  This file
#'   should contain columns such as 'gene_id', 'aa_position', 'ref_aa', and 'aa'.
#' @param amino_acids Path to the output file where the table of reference and
#'   alternate alleles will be written.
#'
#' @return This function does not return a value but writes a tab-separated file
#'   to the path specified by \code{amino_acids}. The file contains columns
#'   'gene_pos', 'ref_aa', and 'aa', representing the gene position, reference
#'   amino acid, and alternate amino acid, respectively.
#'
#' @importFrom dplyr %>% mutate distinct filter
#' @importFrom readr read_tsv write_tsv
#'
#' @examples
#' \dontrun{
#' # Assuming 'input_data.tsv' exists in the working directory
#' create_ref_alt(
#'   input_path = "input_data.tsv",
#'   amino_acids = "alt_alleles.tsv"
#' )
#' }
#'
#' @export
create_ref_alt <-function(input_path, amino_acids) {
    # Reads the input file and converts it to a list of all of the reference and
    # alternate alleles that are present.
    data <- read_tsv(input_path, show_col_types = FALSE)
    ref_alt <- data %>%
      mutate(gene_pos = paste(gene_id, aa_position, sep = "_")) %>%
      distinct(gene_pos, ref_aa, aa) %>%
      filter(ref_aa != aa)
    write_tsv(ref_alt, amino_acids)
}

#' @title Run SNP-slice
#'
#' @description This function executes the SNP-slice program. In theory, it can
#' work with any model - as long as the correct hardcoded snp-slice inputs have
#' been generated, but it has only been tested with a negative binomial model,
#' and some of the other models may require additional input files that are
#' not generated by upstream functions.
#'
#' @param gap Integer specifying the number of iterations of no improvement before
#'   stopping the SNP-slice algorithm.
#' @param script_path Path to the SNP-slice R script (`snpslicemain.R`).
#' @param model Integer indicating the model number to use in SNP-slice. Default
#' is 3 (negative binomial).
#' @param nmcmc Integer specifying the number of MCMC iterations. Default is 10000.
#' @param alpha Numeric value for the alpha parameter in SNP-slice. Default is 2.
#' @param rep Integer representing the replicate number. Default is 1.
#'
#' @return A list containing:
#'   \item{plsf_table}{A data frame with haplotype sequences and their
#'   SNPslice frequencies.}
#'   \item{runtime}{The execution time of the SNP-slice command.}
#'
#' @importFrom dplyr %>% add_column
#'
#' @examples
#' \dontrun{
#' # Assuming 'snpslicemain.R' is in the 'snp-slice' directory
#' result <- run_SNPslice(
#'   gap = 50,
#'   script_path = "/path/to/snp-slice/snpslicemain.R",
#'   model = 3,
#'   nmcmc = 10000,
#'   alpha = 2,
#'   rep = 1
#' )
#' print(result$plsf_table)
#' print(result$runtime)
#' }
#'
#' @export
run_SNPslice <- function(gap, script_path, ref, alt, snp_slice_dir, model = 3, nmcmc = 10000, alpha = 2, rep = 1) {
    #setwd('/home/alfred/github_pipelines/snp-slice')
    output_dir='output' #this output folder is hardcoded in snpslicemain.R so needs to be hardcoded as the same value here
    dir.create(file.path(output_dir), showWarnings = FALSE)
    command <- paste(
        "Rscript ", script_path,
        " model=", model, " nmcmc=", nmcmc, " alpha=", alpha, " gap=", gap,
        " input=", ref, " input2=", alt, " output_dir=", output_dir, " snp_slice_code=", snp_slice_dir,
        sep = ""
    )
    print(command)
    runtime <- system.time({
        system(command)
    })
    D_filename <- paste(output_dir, "/neg_D_nmcmc", nmcmc, "_gap", gap, "_rep", rep, ".txt", sep = "")
    A_filename <- paste(output_dir, "/neg_A_nmcmc", nmcmc, "_gap", gap, "_rep", rep, ".txt", sep = "")
    haplotype_dict_path <- D_filename
    host_strain_association <- A_filename
    plsf_table <- infer_SNPslice_freqs(haplotype_dict_path, host_strain_association)
    return(
        list(
            plsf_table = plsf_table,
            runtime = runtime
        )
    )
}

#' @title Infer haplotype frequencies from SNP-slice output.
#'
#' @description This function reads the output files from SNP-slice, calculates
#' the frequency of each haplotype, and returns a table of haplotype sequences
#' and their frequencies.
#'
#' @param haplotype_dict Path to the haplotype dictionary file (D file)
#' generated by SNP-slice.
#' @param host_strain_association Path to the host-strain association file
#' (A file) generated by SNP-slice.
#'
#' @return A dataframe with two columns:
#'   \item{sequence}{The haplotype sequence (concatenated amino acids).}
#'   \item{SNPslice_frequency}{The calculated frequency of the haplotype.}
#'   \item{sum_column}{The total sum of A, repeated for the number of rows in
#'   collapsed_table}
#'
#' @importFrom readr read_table
#' @importFrom dplyr %>% add_column
#'
#' @examples
#' \dontrun{
#' # Assuming 'example_neg_D_nmcmc10000_gap50_rep1.txt' and
#' 'example_neg_A_nmcmc10000_gap50_rep1.txt' have been created by run_snp-slice
#' freqs <- infer_SNPslice_freqs(
#'   haplotype_dict = example_neg_D_nmcmc10000_gap50_rep1.txt,
#'   host_strain_association = example_neg_A_nmcmc10000_gap50_rep1.txt
#' )
#' print(freqs)
#' }
#'
#' @export
infer_SNPslice_freqs <- function(haplotype_dict, host_strain_association) {
    # Read allele association output
    D <- read.table(haplotype_dict, header = FALSE, sep = "\t")
    A <- read.table(host_strain_association, header = FALSE, sep = "\t")
    # Calculate the frequency for each of the haplotypes
    column_sums <- colSums(A)
    total_sum <- sum(A)
    column_sum_ratios <- column_sums / total_sum
    row_strings <- apply(D, 1, paste, collapse = "")
    combined_table <- cbind(row_strings, column_sum_ratios)
    colnames(combined_table) <- c("sequence", "SNPslice_frequency")
    combined_table <- as.data.frame(combined_table, stringsAsFactors = FALSE)
    combined_table$SNPslice_frequency <- as.numeric(combined_table$SNPslice_frequency)
    # Collapse the table by summing SNPslice_frequency for each sequence
    collapsed_table <- aggregate(SNPslice_frequency ~ sequence, combined_table, sum)
    size <- nrow(collapsed_table)
    sum_column <- rep(total_sum, size)
    new_collapsed <- collapsed_table %>% add_column(sum_column)
    return(new_collapsed)
}


#' @title Get alternate alleles for loci.
#'
#' @description This function reads an assignments file and an alternate counts
#' file, and returns a dataframe mapping loci to their reference and alternate
#' alleles. This dataframe will later be used to produce a finalized STAVE
#' formatted output file.
#'
#' @param assignments Path to the assignments file, which should contain columns
#'   'gene_pos', 'ref_aa', and 'alt_aa'.
#' @param alt_counts Path to the alternate counts file. The first row's column names
#'   (excluding the first column) are assumed to be loci.
#'
#' @return A data frame with columns 'locus', 'ref_aa', and 'alt_aa'.
#'
#' @importFrom readr read_tsv
#' @importFrom dplyr %>% select left_join tibble
#'
#' @examples
#' \dontrun{
#' # Assuming 'alt_alleles' and 'example_read1.txt' have been already generated
#' alt_alleles <- get_alternates(
#'   assignments = "alt_alleles.tsv",
#'   alt_counts = "example_read1.txt"
#' )
#' print(alt_alleles)
#' }
#'
#' @export
get_alternates <- function(assignments, alt_counts) {
  alt_dict <- read_tsv(assignments, col_names = c("gene_pos", "ref_aa", "alt_aa"), show_col_types = FALSE) %>%
    select(gene_pos, ref_aa, alt_aa)
  loci <- read_tsv(alt_counts, n_max = 1, show_col_types = FALSE) %>%
    colnames() %>%
    .[-1]
  
  loci_df <- tibble(locus = loci) %>%
    left_join(alt_dict, by = c("locus" = "gene_pos"))
  
  return(loci_df)
}

#' @title Convert a genotype to STAVE format.
#'
#' @description This function takes a dataframe representing a genotype and
#' converts it into a STAVE format string.
#'
#' @param found_genotype A data frame with columns 'locus' and 'alt', where 'locus'
#'   represents the gene and amino acid position, and 'alt' represents the alternate
#'   amino acid.
#'
#' @return A string representing the genotype in STAVE format.
#'
#' @importFrom dplyr %>% mutate arrange group_by summarize pull
#' @importFrom stringr str_extract str_c
#'
#' @examples
#' # Example genotype data frame
#' genotype_data <- data.frame(
#'   locus = c("gene1_104", "gene2_93", "gene2_255"),
#'   alt = c("R", "M", "K")
#' )
#'
#' # Convert to STAVE format
#' stave_string <- genotype_to_stave(genotype_data)
#' print(stave_string) # Output: "10_A_20_C:gene1;15_G:gene2"
#'
#' @export
genotype_to_stave <- function(found_genotype) {
  print('found is')
  print(found_genotype)
  found_genotype %>%
    mutate(
      gene = str_extract(locus, "^.*(?=_[0-9]+$)"),
      pos = as.integer(str_extract(locus, "[0-9]+$"))
    ) %>%
    arrange(gene, pos) %>%
    group_by(gene) %>%
    summarize(
      stave_string = paste(
        str_c(pos, collapse = "_"), 
        str_c(alt, collapse = ""),
        sep = ":"
      )
    ) %>%
    summarize(stave_string = str_c(stave_string, collapse = ";")) %>%
    pull(stave_string)
}

#' @title Lookup genotype from a character string.
#'
#' @description This function takes a genotype string (e.g., "010") and a
#' dataframe of genotype mappings to determine the alternate alleles for each
#' locus in the genotype.
#'
#' @param genotype A character string representing the genotype, where each
#'   character corresponds to an allele at a locus (e.g., "0" for reference,
#'   "1" for alternate).
#' @param genotype_mappings A data frame with columns 'locus', 'ref_aa', and
#'   'alt_aa', mapping loci to their reference and alternate amino acids.
#'
#' @return A tibble with columns 'locus' and 'alt', where 'locus' is the
#'   gene and amino acid position, and 'alt' is the corresponding amino acid
#'   allele determined from the genotype string.
#'
#' @importFrom tibble tibble
#' @importFrom stringr str_split
#' @importFrom dplyr %>% mutate select
#'
#' @examples
#' # Example genotype and mappings
#' genotype_str <- "010"
#' mappings <- tibble::tibble(
#'   locus = c("gene1_10", "gene1_20", "gene2_15"),
#'   ref_aa = c("R", "V", "I"),
#'   alt_aa = c("Q", "I", "L")
#' )
#'
#' # Lookup the genotype
#' genotype_alleles <- lookup_genotype(genotype_str, mappings)
#' print(genotype_alleles)
#'
#' @export
lookup_genotype <- function(genotype, genotype_mappings) {
  tibble::tibble(
    char = unlist(stringr::str_split(genotype, "")),
    locus = genotype_mappings$locus
  ) %>%
    dplyr::mutate(
      alt = ifelse(char == "0", genotype_mappings$ref_aa, genotype_mappings$alt_aa)
    ) %>%
    dplyr::select(locus, alt)
}


#' @title Process frequencies and generate output.
#'
#' @description This function reads frequency estimates, determines the corresponding
#' genotypes, converts them to STAVE format, and writes the results to an
#' output file.
#'
#' @param freq_estimates Path to the input file containing frequency estimates.
#'   This file is expected to be a TSV.
#' @param output_file Path to the output file where the processed data will be
#'   written. This will be a TSV file.
#' @param genotype_mappings A data frame with columns 'locus', 'ref_aa', and
#'   'alt_aa', mapping loci to their reference and alternate amino acids.
#'
#' @return This function does not return a value but writes a TSV file to the
#'   specified \code{output_file}. The output file contains the genotype in
#'   STAVE format, its frequency, and the total genotype count.
#'
#' @importFrom readr read_tsv write_tsv
#' @importFrom dplyr %>% rowwise mutate ungroup select rename
#'
#' @examples
#' \dontrun{
#' # Assuming 'snp-slice_freqs.tsv' exists and the genotype_mappings dataframe
#' has already been created
#' genotypes_from_freqs(
#'   freq_estimates = "freq_estimates.tsv",
#'   output_file = "output.tsv",
#'   genotype_mappings = genotype_mappings # Or create a sample df
#' )
#' }
#'
#' @export
genotypes_from_freqs <- function(freq_estimates, output_file, genotype_mappings) {
  freqs <- readr::read_tsv(freq_estimates, show_col_types = FALSE)

  header_dict <- names(freqs)


  output <- freqs %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
      found_genotype = list(lookup_genotype(plsf_table.sequence, genotype_mappings)),
      stave_string = genotype_to_stave(found_genotype)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(stave_string, plsf_table.SNPslice_frequency, plsf_table.sum_column) %>%
    dplyr::rename(
      frequency = plsf_table.SNPslice_frequency,
      total_genotype_count = plsf_table.sum_column
    )

  readr::write_tsv(output, output_file)
}

opts <- list(
  make_option(
    "--aa_calls",
    help = str_c(
      "TSV containing amino acid calls, with the columns: specimen_id, ", 
      "target_id, gene_id, aa_position, ref_codon, ref_aa, codon, aa"
    )
  ),
  make_option(
    "--output", 
    help = "final stave output path"
  ),
  make_option(
    "--gap", 
    help = "how many iterations of no improvement before stopping"
  ),
  make_option(
    "--snp_slice_dir", 
    help = "path to cloned snp-slice github repo"
  ),
  make_option(
    "--model", 
    help = "which model number to use, see snp-slice github for documentation"
  )
)

working_directory <- getwd()
print(working_directory)
arg <- parse_args(OptionParser(option_list = opts))
assignments <- 'alt_alleles.tsv'
output_ref <- paste(working_directory,'/inputdata/example_read0.txt', sep="")
output_alt <- paste(working_directory,'/inputdata/example_read1.txt', sep="")
freq_estimates <- 'snp-slice_freqs.tsv'

#this block is only used for testing purposes (arguments not from command line)
#aa_calls <- '/home/alfred/github_pipelines/PGEcore/data/example_amino_acid_calls.tsv'
#gap <- '50'
#create_ref_alt(aa_calls, assignments)
#create_SNP_slice_input(aa_calls, output_ref, output_alt)
#output_list=run_SNPslice(output_alt, output_ref, getwd(), gap=gap)
#output_file <- 'final_stave2.tsv'



#the blocks below use arguments from the command line
output_file <- arg$output
#reformats standardized input data to SNP-Slice format

# setwd(arg$snp_slice_dir)

#creates a simplified table of the reference and alternative alleles associated
#with each gene position
create_ref_alt(arg$aa_calls, assignments)
create_SNP_slice_input(arg$aa_calls, output_ref, output_alt)
#runs SNP-Slice
output_list=run_SNPslice(gap=arg$gap, output_ref, output_alt,
  script_path='scripts/snp-slice_wrapper/adapted_snpslicemain.R',
  model=arg$model, snp_slice_dir=arg$snp_slice_dir)

#these blocks use inputs from the steps above and don't depend directly on any
#command line arguments.
freq=output_list[1]
#loads ref_alt mappings into a dataframe
genotype_mappings <- get_alternates(assignments, output_alt)

setwd(working_directory)
write.table(freq, freq_estimates, sep = "\t", row.names = FALSE, quote = FALSE)

# Execute the function
genotypes_from_freqs(freq_estimates, output_file, genotype_mappings)
#roxygen2::roxygenise() # this command fails - I think likely because roxygen
#expects this script to already be packaged up as an R package. I'm leaving this
#commented out since I'm unsure of the final desired R packaging structure.

# TODO: Store my snp slice in this directory.
# TODO: edit my snp slice to take a snp slice dir and source scripts from there 